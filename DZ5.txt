Практическое задание по теме «Операторы, фильтрация, сортировка и ограничение»
1.Пусть в таблице users поля created_at и updated_at оказались незаполненными. 
Заполните их текущими датой и временем.
---
SELECT * FROM users;
DROP TABLE IF EXISTS users;
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255),
  birthday_at DATE,
  created_at DATETIME,
  updated_at DATETIME);

INSERT INTO users (name, birthday_at, created_at, updated_at)
VALUES 
  ('Анатолий', '1989-05-05', NULL, NULL), 
  ('Мария', '1991-01-30', NULL, NULL),
  ('Светлана', '1999-09-21', NULL, NULL),
  ('Максим', '2001-03-14', NULL, NULL),
  ('Иван', '2011-01-18', NULL, NULL),
  ('Виктория', '1986-11-03', NULL, NULL);
---

UPDATE users
  SET created_at = NOW(), updated_at = NOW();

2.Таблица users была неудачно спроектирована. Записи created_at и updated_at были заданы 
типом VARCHAR и в них долгое время помещались значения в формате 20.10.2017 8:10.
 Необходимо преобразовать поля к типу DATETIME, сохранив введённые ранее значения.
DESC users;
SELECT * FROM users;
ALTER TABLE users ADD new_created_at DATETIME, 
  ADD new_updated_at DATETIME;
UPDATE users 
SET 
  new_created_at = STR_TO_DATE(created_at, '%y.%m.%d %h:%i:%s'),
  new_updated_at = STR_TO_DATE(updated_at, '%y.%m.%d %h:%i:%s');
ALTER TABLE users 
    DROP created_at, DROP updated_at, 
    RENAME COLUMN new_created_at TO created_at, RENAME COLUMN new_updated_at TO updated_at;
-- 
ALTER TABLE
  users
CHANGE
  created_at created_at DATETIME DEFAULT CURRENT_TIMESTAMP;

ALTER TABLE
  users
CHANGE
  updated_at updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;
--
3.В таблице складских запасов storehouses_products в поле value могут встречаться самые 
разные цифры: 0, если товар закончился и выше нуля, если на складе имеются запасы. 
Необходимо отсортировать записи таким образом, чтобы они выводились в порядке увеличения 
значения value. Однако нулевые запасы должны выводиться в конце, после всех записей.

SELECT * FROM storehouses_products;
DROP TABLE IF EXISTS storehouses_products;
CREATE TABLE storehouses_products (
  id SERIAL PRIMARY KEY,
  storehouse_id INT UNSIGNED,
  product_id INT UNSIGNED,
  value INT UNSIGNED, 
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Запасы на складе';

INSERT INTO
    storehouses_products (storehouse_id, product_id, value)
VALUES
    (1, 2, 700),
    (1, 35, 0),
    (1, 554, 12),
    (1, 72, 325),
    (1, 8210, 0);

SELECT 
  value
FROM
  storehouses_products ORDER BY CASE WHEN value = 0 then 1 else 0 end, value;


4.(по желанию) Из таблицы users необходимо извлечь пользователей, родившихся в августе и мае.
 Месяцы заданы в виде списка английских названий (may, august)

SELECT * FROM users WHERE birthday_at RLIKE '^[0-9]{4}-(05|08)-[0-9]{2}';


5.(по желанию) Из таблицы catalogs извлекаются записи при помощи запроса. 
SELECT * FROM catalogs WHERE id IN (5, 1, 2); Отсортируйте записи в порядке, 
заданном в списке IN.

SELECT * FROM catalogs 
WHERE id IN (5, 1, 2)
ORDER BY FIELD (id, 5, 1, 2);

Практическое задание теме «Агрегация данных»:
1.Подсчитайте средний возраст пользователей в таблице users.

SELECT ROUND(AVG((TO_DAYS(NOW()) - TO_DAYS(birthday_at)) / 365.25), 0) AS middle_age FROM users;

2.Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели. 
Следует учесть, что необходимы дни недели текущего года, а не года рождения.
--
SELECT
    DAYNAME(CONCAT(YEAR(NOW()), '-', SUBSTRING(birthday_at, 6, 10))) AS day,
    COUNT(*) AS stats
FROM
    users
GROUP BY 
    day
ORDER BY
	stats DESC;


-- gb
SELECT 
  DATE_FORMAT(DATE(CONCAT('-', YEAR(NOW()), MONTH(birthday_at), DAY(birthday_at))), '%W') AS day, 
  count(*) as stats 
FROM 
  users 
GROUP BY 
  day,
ORDER BY 
  stats DESC;


3.(по желанию) Подсчитайте произведение чисел в столбце таблицы.


SELECT ROUND(exp(SUM(ln(value))), 0) as factorial FROM catalogs;



